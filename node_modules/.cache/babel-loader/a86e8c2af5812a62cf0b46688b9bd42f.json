{"ast":null,"code":"var _jsxFileName = \"/Users/Damien/tasktracker/src/App.js\",\n    _s = $RefreshSig$();\n\nimport Header from './components/Header';\nimport Tasks from './components/Tasks';\nimport AddTask from './components/AddTask';\nimport Footer from './components/Footer';\nimport { useState } from 'react';\nimport { useEffect } from 'react'; // Deals with side-effects, Component needs to do something AFTER rendering\n// Components can be Functions (with hooks) or Classes\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction App() {\n  _s();\n\n  // App (Global) State.\n  // Not best practice, will use Redux to keep track of JS States in future\n  // tasks is RETURNED stateful value, default will be initialState (when event not triggered yet)\n  // setTasks is function to change State. Reusable in different contexts\n  // initialize useState to default value as seen below\n  const [tasks, setTasks] = useState([]); // Fetch data from db.json, so empty brackets here\n\n  const [showAddButton, setshowAddButton] = useState(false); // UseEffect function. Input is the function you passed in (the effect you want to create).\n  // React will call this function after the DOM updates\n\n  useEffect(() => {\n    // First Argument of useEffect (the function that causes the Effect)\n    const getTasks = async () => {\n      const TasksFromServer = await fetchTasks(); // Fetch tasks from Backend Server (Port 5000)\n\n      setTasks(TasksFromServer); // Update on GUI using State Hook function\n    }; // Actually run getTasks(), whatever was above is just a definition\n\n\n    getTasks();\n  }, // Second Argument of useEffect\n  [] // Optional Dependency Array (2nd argument of useEffect). Effect will only execute when value here is different from previous update\n  ); // fetchTasks (from Server) function, declared outside so that we can reuse it in other places\n\n  const fetchTasks = async () => {\n    // async keyword, put infront of function keyword to turn it into async function// Invoking the async function now, returns a promise (async function return values guaranteed to be promises)\n    // We use asynchronous function here as HTTP requests take alot of time, so the function will run in the background (it won't pause execution of entire programme)\n    // It is similar to non-blocking assignment in Verilog\n    // await keyword only works inside async functions\n    // await can be put infront of any async promise-based function, to pause code on that line until the promise fufills, then it returns the resulting value\n    const response = await fetch('http://localhost:5000/tasks'); // Fetches resources from a Network Location\n\n    const data = await response.json(); // When exchanging data between browser and server, the data can only be text. JSON servers as intermediary.\n    // Can replace with any backend here, to fetch data\n    // Return the data for handling\n\n    return data;\n  };\n\n  const fetchSpecificTask = async id => {\n    const response = await fetch(`http://localhost:5000/tasks/${id}`);\n    const data = await response.json();\n    return data;\n  }; // Function to toggle Reminders on Task\n  // Supports Backend Integration as well\n\n\n  const toggleReminder = async id => {\n    // Fetch SPECIFIC DATA from Backend, (which task needs it's reminder to be toggled?)\n    const TaskToToggle = await fetchSpecificTask(id); // Update the SPECIFIC DATA that has just been fetched\n    // 1. Use Spread Operator to copy over fetched data\n    // 2. Accessing the reminder field, change it to the opposite of JUST FETCHED DATA'S REMINDER! In this case it is TaskToToggle\n\n    const updatedTaskToToggle = { ...TaskToToggle,\n      reminder: !TaskToToggle.reminder\n    }; // Push the Updated Data onto Backend Server\n\n    const response = await fetch(`http://localhost:5000/tasks/${id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-type': 'application/json'\n      },\n      body: JSON.stringify(updatedTaskToToggle)\n    });\n    const data = await response.json(); // Reflect updated Data on UI\n\n    setTasks(tasks.map(ReminderTasks => // ReminderTasks is the \"placeholder\" for the current element, as you iterate through List\n    ReminderTasks.id === id ? { ...ReminderTasks,\n      reminder: data.reminder // Rest Operator\n\n    } : ReminderTasks));\n  }; // Function to add Task\n\n\n  const onAdd = async TaskAdded => {\n    // ADD request to Backend Server, causing db.json to be modified also!\n    const serverData = await fetch('http://localhost:5000/tasks', {\n      method: 'POST',\n      headers: {\n        'Content-type': 'application/json'\n      },\n      body: JSON.stringify(TaskAdded) // Convert TaskAdded (input) into JSON format, for adding into Backend Database\n\n    });\n    /* Why don't we just add TaskAdded directly using the Redundant Method?\n    We first wait for the data to be added to Backend Server, before we update it in the UI. That flows better\n     */\n\n    const JSData = await serverData.json(); // Convert JSON format back to JS\n\n    setTasks([...tasks, JSData]); // tasks is the Stateful Value. JSData can be replaced with TaskAdded\n\n    /* REDUNDANT METHOD TO ADD TASKS, WE WILL USE JSON-SERVER\n    // Function to add Task\n    // Input TaskAdded does not need to be explicitly defined in App.js (it is just a placeholder, like C)\n    // TaskAdded input is dependent on AddTask.js (it is task, date, reminder)\n    // Without a database, we will simply use RNG to store the different Tasks\n    const id = Math.floor(Math.random() * 10000) + 1\n     // Create an Object representing newly added Task, using spread operator for TaskAdded (containing text,day,reminder)\n    const newTask = {id, ...TaskAdded}\n     // Define (reuse) the setTasks function to include the new task\n    // Copy over the pre-existing TASKS (the Stateful Value above)\n    // Append newTask to it\n    setTasks( [...tasks, newTask])\n     */\n  }; // Function to delete Task (known as deleteTask in Tasks.js / Task.js, since that is what we called it as a Prop)\n  // Supports additional functionality (deleting Task from Backend db.json Database as well)\n\n\n  const deleteTask = async id => {\n    // DELETE request from Backend Server, this causes db.json to be modified also!\n    await fetch(`http://localhost:5000/tasks/${id}`, {\n      method: 'DELETE'\n    }); // Note backticks and String Template\n    // Delete from UI\n\n    setTasks(tasks.filter(FilteredTask => FilteredTask.id !== id));\n  }; // Return is JSX, not HTML\n  // Can only return one single Parent Element\n\n  /* Pass in deleteTask function as Prop, to Tasks.js\n     - Tasks.js contains Task.js\n     - Task.js contains the button itself, that is the trigger point for deletion\n      Pass in addTask function as Prop, to AddTask.js\n   */\n\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"container\",\n    children: [/*#__PURE__*/_jsxDEV(Header, {\n      buttonColorDecider: showAddButton,\n      toggleAdd: () => setshowAddButton(!showAddButton)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 144,\n      columnNumber: 9\n    }, this), \"      \", showAddButton ? /*#__PURE__*/_jsxDEV(AddTask, {\n      onAdd: onAdd\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 147,\n      columnNumber: 26\n    }, this) : '', \"                 \", tasks.length !== 0 ? /*#__PURE__*/_jsxDEV(Tasks, {\n      tasks: tasks\n      /* Passing in tasks as Prop */\n      ,\n      onDelete: deleteTask\n      /* Passing in deleteTask (FUNCTION) as Prop, into variable onDelete */\n      ,\n      toggleReminder: toggleReminder\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 151,\n      columnNumber: 20\n    }, this) : 'No Tasks Today!', /*#__PURE__*/_jsxDEV(Footer, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 161,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 142,\n    columnNumber: 5\n  }, this);\n}\n\n_s(App, \"voSfSYitr6OBIF679Ndd0aVzGgs=\");\n\n_c = App;\nexport default App;\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"sources":["/Users/Damien/tasktracker/src/App.js"],"names":["Header","Tasks","AddTask","Footer","useState","useEffect","App","tasks","setTasks","showAddButton","setshowAddButton","getTasks","TasksFromServer","fetchTasks","response","fetch","data","json","fetchSpecificTask","id","toggleReminder","TaskToToggle","updatedTaskToToggle","reminder","method","headers","body","JSON","stringify","map","ReminderTasks","onAdd","TaskAdded","serverData","JSData","deleteTask","filter","FilteredTask","length"],"mappings":"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","sourcesContent":["import Header from './components/Header'\nimport Tasks from './components/Tasks'\nimport AddTask from './components/AddTask'\nimport Footer from './components/Footer'\nimport {useState} from 'react'\nimport {useEffect} from 'react'   // Deals with side-effects, Component needs to do something AFTER rendering\n\n\n// Components can be Functions (with hooks) or Classes\nfunction App() {\n\n// App (Global) State.\n// Not best practice, will use Redux to keep track of JS States in future\n\n    // tasks is RETURNED stateful value, default will be initialState (when event not triggered yet)\n    // setTasks is function to change State. Reusable in different contexts\n    // initialize useState to default value as seen below\n    const [tasks, setTasks] = useState([])      // Fetch data from db.json, so empty brackets here\n    const [showAddButton, setshowAddButton] = useState(false)\n\n    // UseEffect function. Input is the function you passed in (the effect you want to create).\n    // React will call this function after the DOM updates\n    useEffect( () => {\n        // First Argument of useEffect (the function that causes the Effect)\n        const getTasks = async() => {\n               const TasksFromServer = await(fetchTasks())          // Fetch tasks from Backend Server (Port 5000)\n               setTasks(TasksFromServer)                            // Update on GUI using State Hook function\n        }\n\n        // Actually run getTasks(), whatever was above is just a definition\n        getTasks()\n        },\n\n        // Second Argument of useEffect\n        []  // Optional Dependency Array (2nd argument of useEffect). Effect will only execute when value here is different from previous update\n    )\n\n    // fetchTasks (from Server) function, declared outside so that we can reuse it in other places\n    const fetchTasks = async() => {                                           // async keyword, put infront of function keyword to turn it into async function// Invoking the async function now, returns a promise (async function return values guaranteed to be promises)\n        // We use asynchronous function here as HTTP requests take alot of time, so the function will run in the background (it won't pause execution of entire programme)\n        // It is similar to non-blocking assignment in Verilog\n\n        // await keyword only works inside async functions\n        // await can be put infront of any async promise-based function, to pause code on that line until the promise fufills, then it returns the resulting value\n        const response = await fetch('http://localhost:5000/tasks')   // Fetches resources from a Network Location\n        const data = await response.json()    // When exchanging data between browser and server, the data can only be text. JSON servers as intermediary.\n                                              // Can replace with any backend here, to fetch data\n        // Return the data for handling\n        return data\n    }\n\n    const fetchSpecificTask = async(id) => {\n        const response = await fetch(`http://localhost:5000/tasks/${id}`)\n        const data = await response.json()\n        return data\n    }\n\n    // Function to toggle Reminders on Task\n    // Supports Backend Integration as well\n    const toggleReminder = async (id) =>\n    {\n        // Fetch SPECIFIC DATA from Backend, (which task needs it's reminder to be toggled?)\n        const TaskToToggle = await fetchSpecificTask(id)\n\n        // Update the SPECIFIC DATA that has just been fetched\n        // 1. Use Spread Operator to copy over fetched data\n        // 2. Accessing the reminder field, change it to the opposite of JUST FETCHED DATA'S REMINDER! In this case it is TaskToToggle\n        const updatedTaskToToggle = {...TaskToToggle, reminder : !TaskToToggle.reminder }\n\n        // Push the Updated Data onto Backend Server\n        const response = await fetch(`http://localhost:5000/tasks/${id}`, {\n            method : 'PUT',\n            headers : { 'Content-type' : 'application/json',},\n            body : JSON.stringify(updatedTaskToToggle),\n            }\n        )\n\n        const data = await response.json()\n\n        // Reflect updated Data on UI\n        setTasks( tasks.map(\n            (ReminderTasks) => (            // ReminderTasks is the \"placeholder\" for the current element, as you iterate through List\n                ReminderTasks.id === id ?\n                    {\n                        ...ReminderTasks, reminder : data.reminder    // Rest Operator\n                    } : ReminderTasks\n            )\n        ))\n    }\n\n    // Function to add Task\n    const onAdd = async(TaskAdded) => {\n        // ADD request to Backend Server, causing db.json to be modified also!\n        const serverData = await fetch('http://localhost:5000/tasks' , {\n            method: 'POST',\n            headers: {'Content-type': 'application/json'},\n            body: JSON.stringify(TaskAdded),                     // Convert TaskAdded (input) into JSON format, for adding into Backend Database\n        })\n\n        /* Why don't we just add TaskAdded directly using the Redundant Method?\n        We first wait for the data to be added to Backend Server, before we update it in the UI. That flows better\n         */\n        const JSData = await serverData.json()    // Convert JSON format back to JS\n        setTasks( [...tasks, JSData])       // tasks is the Stateful Value. JSData can be replaced with TaskAdded\n\n        /* REDUNDANT METHOD TO ADD TASKS, WE WILL USE JSON-SERVER\n        // Function to add Task\n        // Input TaskAdded does not need to be explicitly defined in App.js (it is just a placeholder, like C)\n        // TaskAdded input is dependent on AddTask.js (it is task, date, reminder)\n        // Without a database, we will simply use RNG to store the different Tasks\n        const id = Math.floor(Math.random() * 10000) + 1\n\n        // Create an Object representing newly added Task, using spread operator for TaskAdded (containing text,day,reminder)\n        const newTask = {id, ...TaskAdded}\n\n        // Define (reuse) the setTasks function to include the new task\n        // Copy over the pre-existing TASKS (the Stateful Value above)\n        // Append newTask to it\n        setTasks( [...tasks, newTask])\n         */\n    }\n\n    // Function to delete Task (known as deleteTask in Tasks.js / Task.js, since that is what we called it as a Prop)\n    // Supports additional functionality (deleting Task from Backend db.json Database as well)\n    const deleteTask = async(id) => {\n        // DELETE request from Backend Server, this causes db.json to be modified also!\n        await fetch(`http://localhost:5000/tasks/${id}` ,{method : 'DELETE'} )  // Note backticks and String Template\n        // Delete from UI\n        setTasks( tasks.filter( (FilteredTask) => FilteredTask.id !== id ) )\n    }\n\n  // Return is JSX, not HTML\n  // Can only return one single Parent Element\n\n  /* Pass in deleteTask function as Prop, to Tasks.js\n     - Tasks.js contains Task.js\n     - Task.js contains the button itself, that is the trigger point for deletion\n\n     Pass in addTask function as Prop, to AddTask.js\n   */\n  return (\n    <div className = 'container'>\n\n        <Header\n            buttonColorDecider = {showAddButton}\n            toggleAdd = { () => setshowAddButton(!showAddButton) }/>      {/* Button is in <Header>, so we must pass down the State Hook function as a Prop. We also define the State Hook function here */}\n        {showAddButton ? <AddTask onAdd = {onAdd}/> : ''}                 {/* Event Handlers must be function or function reference, for setshowAddButton*/}\n        {\n           tasks.length !== 0 ?\n               (\n                   <Tasks\n                       tasks = {tasks}         /* Passing in tasks as Prop */\n                       onDelete = {deleteTask} /* Passing in deleteTask (FUNCTION) as Prop, into variable onDelete */\n                       toggleReminder = {toggleReminder}\n                   />\n               )\n               :\n               'No Tasks Today!'\n        }\n\n        <Footer />\n\n    </div>\n  );\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}