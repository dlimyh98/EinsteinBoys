{"ast":null,"code":"import _toConsumableArray from\"/Users/Damien/tasktracker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"/Users/Damien/tasktracker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _regeneratorRuntime from\"/Users/Damien/tasktracker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/Damien/tasktracker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/Users/Damien/tasktracker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import Header from'./components/Header';import Tasks from'./components/Tasks';import AddTask from'./components/AddTask';import{useState}from'react';import{useEffect}from'react';// Deals with side-effects, Component needs to do something AFTER rendering\n// Components can be Functions (with hooks) or Classes\nimport{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";function App(){// App (Global) State.\n// Not best practice, will use Redux to keep track of JS States in future\n// tasks is RETURNED stateful value, default will be initialState (when event not triggered yet)\n// setTasks is function to change State. Reusable in different contexts\n// initialize useState to default value as seen below\nvar _useState=useState([]),_useState2=_slicedToArray(_useState,2),tasks=_useState2[0],setTasks=_useState2[1];// Fetch data from db.json, so empty brackets here\nvar _useState3=useState(false),_useState4=_slicedToArray(_useState3,2),showAddButton=_useState4[0],setshowAddButton=_useState4[1];// UseEffect function. Input is the function you passed in (the effect you want to create).\n// React will call this function after the DOM updates\nuseEffect(function(){// First Argument of useEffect (the function that causes the Effect)\nvar getTasks=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var TasksFromServer;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return fetchTasks();case 2:TasksFromServer=_context.sent;fetchTasks(TasksFromServer);case 4:case\"end\":return _context.stop();}}},_callee);}));return function getTasks(){return _ref.apply(this,arguments);};}();// STILl the first argument of useEffect, but now another function (fetching Tasks from Backend)\ngetTasks();},// Second Argument of useEffect\n[]// Optional Dependency Array (2nd argument of useEffect). Effect will only execute when value here is different from previous update\n);// fetchTasks (from Server) function, declared outside so that we can reuse it in other places\nvar fetchTasks=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(){var response,data;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return fetch('http://localhost:5000/tasks');case 2:response=_context2.sent;_context2.next=5;return response.json();case 5:data=_context2.sent;case 6:case\"end\":return _context2.stop();}}},_callee2);}));return function fetchTasks(){return _ref2.apply(this,arguments);};}();// Function to toggle Reminders on Task\nvar toggleReminder=function toggleReminder(id){setTasks(tasks.map(function(ReminderTasks){return ReminderTasks.id===id?_objectSpread(_objectSpread({},ReminderTasks),{},{reminder:!ReminderTasks.reminder// Rest Operator\n}):ReminderTasks;}));};// Function to add Task\n// Input TaskAdded does not need to be explicitly defined in App.js (it is just a placeholder, like C)\n// TaskAdded input is dependent on AddTask.js (it is task, date, reminder)\nvar onAdd=function onAdd(TaskAdded){// Without a database, we will simply use RNG to store the different Tasks\nvar id=Math.floor(Math.random()*10000)+1;// Create an Object representing newly added Task, using spread operator for TaskAdded (containing text,day,reminder)\nvar newTask=_objectSpread({id:id},TaskAdded);// Define (reuse) the setTasks function to include the new task\n// Copy over the pre-existing TASKS (the Stateful Value above)\n// Append newTask to it\nsetTasks([].concat(_toConsumableArray(tasks),[newTask]));};// Function to delete Task (known as deleteTask in Tasks.js / Task.js, since that is what we called it as a Prop)\nvar deleteTask=function deleteTask(id)// Arrow Notation, taking in id as input\n{setTasks(tasks.filter(function(FilteredTask){return FilteredTask.id!==id;}));};// Return is JSX, not HTML\n// Can only return one single Parent Element\n/* Pass in deleteTask function as Prop, to Tasks.js\n     - Tasks.js contains Task.js\n     - Task.js contains the button itself, that is the trigger point for deletion\n\n     Pass in addTask function as Prop, to AddTask.js\n   */return/*#__PURE__*/_jsxs(\"div\",{className:\"container\",children:[/*#__PURE__*/_jsx(Header,{buttonColorDecider:showAddButton,toggleAdd:function toggleAdd(){return setshowAddButton(!showAddButton);}}),\"      \",showAddButton?/*#__PURE__*/_jsx(AddTask,{onAdd:onAdd}):'',\"                 \",tasks.length!==0?/*#__PURE__*/_jsx(Tasks,{tasks:tasks/* Passing in tasks as Prop */,onDelete:deleteTask/* Passing in deleteTask (FUNCTION) as Prop, into variable onDelete */,toggleReminder:toggleReminder}):'No Tasks Today!']});}export default App;","map":{"version":3,"sources":["/Users/Damien/tasktracker/src/App.js"],"names":["Header","Tasks","AddTask","useState","useEffect","App","tasks","setTasks","showAddButton","setshowAddButton","getTasks","fetchTasks","TasksFromServer","fetch","response","json","data","toggleReminder","id","map","ReminderTasks","reminder","onAdd","TaskAdded","Math","floor","random","newTask","deleteTask","filter","FilteredTask","length"],"mappings":"otBAAA,MAAOA,CAAAA,MAAP,KAAmB,qBAAnB,CACA,MAAOC,CAAAA,KAAP,KAAkB,oBAAlB,CACA,MAAOC,CAAAA,OAAP,KAAoB,sBAApB,CACA,OAAQC,QAAR,KAAuB,OAAvB,CACA,OAAQC,SAAR,KAAwB,OAAxB,CAAkC;AAElC;wFACA,QAASC,CAAAA,GAAT,EAAe,CAEf;AACA;AAEI;AACA;AACA;AACA,cAA0BF,QAAQ,CAAC,EAAD,CAAlC,wCAAOG,KAAP,eAAcC,QAAd,eAA4C;AAC5C,eAA0CJ,QAAQ,CAAC,KAAD,CAAlD,yCAAOK,aAAP,eAAsBC,gBAAtB,eAEA;AACA;AACAL,SAAS,CAAE,UAAM,CACb;AACA,GAAMM,CAAAA,QAAQ,0FAAG,6KACoBC,CAAAA,UAAU,EAD9B,QACJC,eADI,eAEVD,UAAU,CAACC,eAAD,CAAV,CAFU,sDAAH,kBAARF,CAAAA,QAAQ,0CAAd,CAIA;AACAA,QAAQ,GACP,CARI,CAUL;AACA,EAAI;AAXC,CAAT,CAcA;AACA,GAAMC,CAAAA,UAAU,2FAAG,iLAMQE,CAAAA,KAAK,CAAC,6BAAD,CANb,QAMTC,QANS,uCAOIA,CAAAA,QAAQ,CAACC,IAAT,EAPJ,QAOTC,IAPS,wEAAH,kBAAVL,CAAAA,UAAU,2CAAhB,CAWI;AACJ,GAAMM,CAAAA,cAAc,CAAG,QAAjBA,CAAAA,cAAiB,CAACC,EAAD,CACvB,CACIX,QAAQ,CAAED,KAAK,CAACa,GAAN,CACN,SAACC,aAAD,QACIA,CAAAA,aAAa,CAACF,EAAd,GAAqBA,EAArB,gCAEWE,aAFX,MAE0BC,QAAQ,CAAG,CAACD,aAAa,CAACC,QAAY;AAFhE,GAGQD,aAJZ,EADM,CAAF,CAAR,CAQH,CAVD,CAYA;AACA;AACA;AACA,GAAME,CAAAA,KAAK,CAAG,QAARA,CAAAA,KAAQ,CAACC,SAAD,CACd,CACI;AACA,GAAML,CAAAA,EAAE,CAAGM,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,GAAgB,KAA3B,EAAoC,CAA/C,CAEA;AACA,GAAMC,CAAAA,OAAO,gBAAIT,EAAE,CAAFA,EAAJ,EAAWK,SAAX,CAAb,CAEA;AACA;AACA;AACAhB,QAAQ,8BAAMD,KAAN,GAAaqB,OAAb,GAAR,CACH,CAZD,CAcA;AACA,GAAMC,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,CAACV,EAAD,CAAW;AAC9B,CACIX,QAAQ,CAAED,KAAK,CAACuB,MAAN,CAAc,SAACC,YAAD,QAAkBA,CAAAA,YAAY,CAACZ,EAAb,GAAoBA,EAAtC,EAAd,CAAF,CAAR,CACH,CAHD,CAKF;AACA;AAEA;AACF;AACA;AACA;AACA;AACA,KACE,mBACE,aAAK,SAAS,CAAG,WAAjB,wBAEI,KAAC,MAAD,EACI,kBAAkB,CAAIV,aAD1B,CAEI,SAAS,CAAK,2BAAMC,CAAAA,gBAAgB,CAAC,CAACD,aAAF,CAAtB,EAFlB,EAFJ,UAKKA,aAAa,cAAG,KAAC,OAAD,EAAS,KAAK,CAAIc,KAAlB,EAAH,CAAgC,EALlD,qBAOOhB,KAAK,CAACyB,MAAN,GAAiB,CAAjB,cAEQ,KAAC,KAAD,EACI,KAAK,CAAIzB,KAAe,8BAD5B,CAEI,QAAQ,CAAIsB,UAAY,sEAF5B,CAGI,cAAc,CAAIX,cAHtB,EAFR,CASI,iBAhBX,GADF,CAqBD,CAED,cAAeZ,CAAAA,GAAf","sourcesContent":["import Header from './components/Header'\nimport Tasks from './components/Tasks'\nimport AddTask from './components/AddTask'\nimport {useState} from 'react'\nimport {useEffect} from 'react'   // Deals with side-effects, Component needs to do something AFTER rendering\n\n// Components can be Functions (with hooks) or Classes\nfunction App() {\n\n// App (Global) State.\n// Not best practice, will use Redux to keep track of JS States in future\n\n    // tasks is RETURNED stateful value, default will be initialState (when event not triggered yet)\n    // setTasks is function to change State. Reusable in different contexts\n    // initialize useState to default value as seen below\n    const [tasks, setTasks] = useState([])      // Fetch data from db.json, so empty brackets here\n    const [showAddButton, setshowAddButton] = useState(false)\n\n    // UseEffect function. Input is the function you passed in (the effect you want to create).\n    // React will call this function after the DOM updates\n    useEffect( () => {\n        // First Argument of useEffect (the function that causes the Effect)\n        const getTasks = async() => {\n               const TasksFromServer = await(fetchTasks())\n               fetchTasks(TasksFromServer)\n        }\n        // STILl the first argument of useEffect, but now another function (fetching Tasks from Backend)\n        getTasks()\n        },\n\n        // Second Argument of useEffect\n        []  // Optional Dependency Array (2nd argument of useEffect). Effect will only execute when value here is different from previous update\n    )\n\n    // fetchTasks (from Server) function, declared outside so that we can reuse it in other places\n    const fetchTasks = async() => {                                           // async keyword, put infront of function keyword to turn it into async function// Invoking the async function now, returns a promise (async function return values guaranteed to be promises)\n        // We use asynchronous function here as HTTP requests take alot of time, so the function will run in the background (it won't pause execution of entire programme)\n        // It is similar to non-blocking assignment in Verilog\n\n        // await keyword only works inside async functions\n        // await can be put infront of any async promise-based function, to pause code on that line until the promise fufills, then it returns the resulting value\n        const response = await fetch('http://localhost:5000/tasks')   // Fetches resources from a Network Location\n        const data = await response.json()    // When exchanging data between browser and server, the data can only be text. JSON servers as intermediary.\n                                              // Can replace with any backend here, to fetch data\n    }\n\n        // Function to toggle Reminders on Task\n    const toggleReminder = (id) =>\n    {\n        setTasks( tasks.map(\n            (ReminderTasks) => (\n                ReminderTasks.id === id ?\n                    {\n                        ...ReminderTasks, reminder : !ReminderTasks.reminder    // Rest Operator\n                    } : ReminderTasks\n            )\n        ))\n    }\n\n    // Function to add Task\n    // Input TaskAdded does not need to be explicitly defined in App.js (it is just a placeholder, like C)\n    // TaskAdded input is dependent on AddTask.js (it is task, date, reminder)\n    const onAdd = (TaskAdded) =>\n    {\n        // Without a database, we will simply use RNG to store the different Tasks\n        const id = Math.floor(Math.random() * 10000) + 1\n\n        // Create an Object representing newly added Task, using spread operator for TaskAdded (containing text,day,reminder)\n        const newTask = {id, ...TaskAdded}\n\n        // Define (reuse) the setTasks function to include the new task\n        // Copy over the pre-existing TASKS (the Stateful Value above)\n        // Append newTask to it\n        setTasks( [...tasks, newTask])\n    }\n\n    // Function to delete Task (known as deleteTask in Tasks.js / Task.js, since that is what we called it as a Prop)\n    const deleteTask = (id) =>    // Arrow Notation, taking in id as input\n    {\n        setTasks( tasks.filter( (FilteredTask) => FilteredTask.id !== id ) )\n    }\n\n  // Return is JSX, not HTML\n  // Can only return one single Parent Element\n\n  /* Pass in deleteTask function as Prop, to Tasks.js\n     - Tasks.js contains Task.js\n     - Task.js contains the button itself, that is the trigger point for deletion\n\n     Pass in addTask function as Prop, to AddTask.js\n   */\n  return (\n    <div className = 'container'>\n\n        <Header\n            buttonColorDecider = {showAddButton}\n            toggleAdd = { () => setshowAddButton(!showAddButton) }/>      {/* Button is in <Header>, so we must pass down the State Hook function as a Prop. We also define the State Hook function here */}\n        {showAddButton ? <AddTask onAdd = {onAdd}/> : ''}                 {/* Event Handlers must be function or function reference, for setshowAddButton*/}\n        {\n           tasks.length !== 0 ?\n               (\n                   <Tasks\n                       tasks = {tasks}         /* Passing in tasks as Prop */\n                       onDelete = {deleteTask} /* Passing in deleteTask (FUNCTION) as Prop, into variable onDelete */\n                       toggleReminder = {toggleReminder}\n                   />\n               )\n               :\n               'No Tasks Today!'\n        }\n    </div>\n  );\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}